---
published: false
layout: post
tag: git
original: https://hackernoon.com/avoiding-accidental-complexity-when-structuring-your-app-state-6e6d22ad5e2a
title: Avoiding Accidental Complexity When Structuring Your App State
author: "Tal Kol"
translator: "Ирина Смышляева"

---

*Redux и другие реализации Flux побуждают нас детально продумывать приложение и отводить время на его моделирование. И оказывается, что это совсем не тривиальная задача. Это классический пример теории хаоса, когда безобидный, казалось бы, трепет крыльев мотылька, позже может обернуться ураганом случайной сложности. Вот несколько практических советов по моделированию состояния (стейта) приложения так, чтобы сохранить здравый ум и бизнес логику настолько, насколько это возможно.*

## Что понимается под состоянием приложения

Согласно [Википедии](https://en.wikipedia.org/wiki/State_%28computer_science%29) компьютерные программы хранят данные в переменных, представляющих собой области хранения данных в памяти компьютера, содержание этих областей памяти в любой момент времени исполнения программы называется *состоянием* программы.

В нашем случае важно добавить слово *минимальный* в это определение. При моделировании состояния приложения, которое можно явно контролировать, мы сделаем все возможное, чтобы иметь дело с минимальным количеством данных, необходимых для выражения этого состояния и игнорировать все вторичные переменные, которые можно вывести из ядра.

В Flux приложениях состояние хранится в сторах. Экшены вызывают его изменения, после чего представление, следящее за изменением состояния, перерисовываются.

<img src='https://cdn-images-1.medium.com/max/1600/1*pgxTL69KXTYjupzGO015Ew.png' alt='flux'/>

Redux, реализация Flux, которую мы рассматриваем, добавляет более строгие требования - все состояние хранится в одном сторе, который при этом является иммутабельным и обычно сериализуемым (упорядочиваемым?).

Советы также должны пригодиться, если вы не используете Redux. А может даже подойдут тем, кто совсем не использует Flux.

## 1. Не ориентируйтесь на API сервера

Локальное состояние приложения часто начинается с сервера. Когда приложение служит для отображения данных, поступающих с удаленного сервера, заманчиво сохранить их структуру как есть.

Как пример рассмотрим приложение для управления интернет-магазином. Продавец будет использовать его для инвентаризации, так что его ключевой элемент - отображение списка продуктов. Список приходит с сервера, но для того, чтобы его можно было отрендерить, он должен локально храниться в состоянии приложения. Давайте предположим, что API для получения списка продуктов с сервера вернет такой JSON:

```
{
  "total": 117,
  "offset": 0,
  "products": [
    {
      "id": "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0",
      "title": "Blue Shirt",
      "price": 9.99
    },
    {
      "id": "aec17a8e-4793-4687-9be4-02a6cf305590",
      "title": "Red Hat",
      "price": 7.99
    }
  ]
}
```

Список продуктов приходит как *массив объектов*, так почему бы не сохранить его в состоянии приложения как массив объектов?

API сервера проектируется определенным образом для определенных задач, которые совсем не обязательно схожи с теми, для решения которых вы проектируете состояние приложения. (The design of server API follows different concerns that don’t necessarily align with the goals your app state structure is trying to achieve.) В нашем случае массив обусловлен, вероятно, пагинацией и сплитингом, чтобы данные загружались по мере необходимости и серверу не приходилось отправлять их несколько раз и он сохранял пропускную способность. Все это важные проблемы сети, но они имеют мало общего с задачами состояния нашего приложения.

## 2. Лучше объекты, чем массивы

В общем, массивы неудобны для поддержания состояния (maintaining state?). Посмотрим, что происходит, когда конкретный продукт нужно обновить или извлечь. Такое может быть, если через приложение изменяется цена, или если нужно обновить данные с сервера. Перебирать большой массив не так удобно, как запрашивать конкретный продукт по его ID.

Так какой совет? Используйте хэшмэп и индексируйте по первичному ключу (primary key).

Это значит, что данные из примера выше можно хранить в состоянии в таком виде:

```
{
  "productsById": {
    "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
      "title": "Blue Shirt",
      "price": 9.99
    },
    "aec17a8e-4793-4687-9be4-02a6cf305590": {
      "title": "Red Hat",
      "price": 7.99
    }
  }
}
```

А если важен порядок сортировки? Например, если нужно отобразить пользователю тот же порядок, который приходит с сервера. Тогда можно хранить дополнительный массив идентификаторов:

```
{
 "productsById": {
   "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
     "title": "Blue Shirt",
     "price": 9.99
   },
   "aec17a8e-4793-4687-9be4-02a6cf305590": {
     "title": "Red Hat",
     "price": 7.99
   }
 },
 "productIds": [
   "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0",
   "aec17a8e-4793-4687-9be4-02a6cf305590"
 ]
}
```

Интересный момент: если мы планируем отобразить данные внутри React Native компонента [ListView](https://facebook.github.io/react-native/docs/listview.html), эта структура действительно очень хорошо работает. Рекомендуемая версия [cloneWithRows](https://facebook.github.io/react-native/docs/listviewdatasource.html#clonewithrows), подерживающая стабильный ID строки, ожидает получить данные именно в таком формате.

## 3. Не подгоняйте состояние под представление

Конечная цель состояния приложения - передаваться в представление и рендериться в удобном для пользователя виде. Есть соблазн избежать дополнительных преобразований и просто хранить такую структуру состояния, которую ждет представление.

Вернемся к нашему примеру. Допустим, что каждый продукт может быть в наличии или нет. Мы можем хранить эти данные как булево значение в объекте продукта:

```
{
  "id": "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0",
  "title": "Blue Shirt",
  "price": 9.99,
  "outOfStock": false
}
```

Приложению нужно отобразить список всех продуктов, которых нет в наличии. Как вы помните, React Native компонента ListView ожидает для своего метода [cloneWithRows](https://facebook.github.io/react-native/docs/listviewdatasource.html#clonewithrows) два аргумента: хэшмэп строк и массив с их ID. Что если заранее все подготовить и хранить этот список в состоянии в явном виде? Это позволит нам передавать оба аргкмента в ListView без дополнительных трансформаций. Структура состояния будет такой:

```
{
  "productsById": {
    "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
      "title": "Blue Shirt",
      "price": 9.99,
      "outOfStock": false
    },
    "aec17a8e-4793-4687-9be4-02a6cf305590": {
      "title": "Red Hat",
      "price": 7.99,
      "outOfStock": true
    }
  },
  "outOfStockProductIds": ["aec17a8e-4793-4687-9be4-02a6cf305590"]
}
```

Кажется хорошей идеей, не правда ли? Но... нет.

Причина, как и в прошлом случае, в том, что у представления другой набор задач. Оно не заботится о том, чтобы сохранять состояние минимальным. Даже наоборот, ведь данные выкладываются для удобства пользователя. Разные представления отображают данные по-разному, и невозможно угодить им всем не дублируя данные. Что приводит нас к следующему пункту...

## 4. Не дублируйте данные в состоянии

Хороший способ понять, есть ли в состоянии дублирующиеся данные - проверить, нужно ли делать обновления в двух местах одновременно для обеспечения согласованности. В примере с товарами "не в наличии", представим, что один из товаров внезапно закончился. Чтобы сделать это изменение мы должны будем и изменить его outOfStock значение в объекте на true, и добавить его ID в массив отсутствующих продуктов - два обновления.

Разобраться с повтором данных просто. Все что нужно сделать - удалить одину из сущностей. Смысл этого происходит из принципа единого источника истины: если данные сохраняются только один раз - несогласованности просто не может быть.

После удалении массива outOfStockProductIds нам все еще нужно найти способ подготовить эти данные для представления. Эти преобразования будут происходить во время выполнения программы, прямо перед тем, как отдать данные представлению. Рекомендуемая практика для Redux приложений - реализовать это в [селекторе](https://egghead.io/lessons/javascript-redux-colocating-selectors-with-reducers):

```
{
  "productsById": {
    "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
      "title": "Blue Shirt",
      "price": 9.99,
      "outOfStock": false
    },
    "aec17a8e-4793-4687-9be4-02a6cf305590": {
      "title": "Red Hat",
      "price": 7.99,
      "outOfStock": true
    }
  }
}

// selector
function outOfStockProductIds(state) {
  return _.keys(_.pickBy(state.productsById, (product) => product.outOfStock));  
}
```

Селектор - это чистая функция, которая принимает состояние в качестве входных данных и возвращает его преобразованную часть, которую мы хотим использовать. [Дэн Абрамов](https://twitter.com/dan_abramov) рекомендует располагать селекторы рядом с редьюсерами, так как обычно они тесно связаны между собой. Мы будем использовать селектор внутри mapStateToProps представления.

Альтернатива удалению массива - удаление значений outOfStock из каждого продукта в объекте. В этом альтернативном подходе мы можем сохранить массив в качестве источника истины. И кстати... следуя совету #2 лучше заменить этот массив объектом:

```
 {
   "productsById": {
     "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
       "title": "Blue Shirt",
       "price": 9.99
     },
     "aec17a8e-4793-4687-9be4-02a6cf305590": {
       "title": "Red Hat",
       "price": 7.99
     }
   },
   "outOfStockProductMap": {
     "aec17a8e-4793-4687-9be4-02a6cf305590": true
   }
 }

 // selector
 function outOfStockProductIds(state) {
  !! не забыть вставить сюда кусок!
 }
```

## 5. Никогда не держите в состоянии то, что можно вычислить

Следовать Принципу единственного источника истины - это больше, чем просто не дублировать данные. Любые вторичные данные в сторе нарушают этот принцип, потому что требуют обновлений в нескольких местах для обеспечения согласованности.

Давайте добавим еще одно требование к нашему примеру - способность размещать продукты для продажи и добавлять скидку к их стоимости. Приложение будет показывать пользователю отфильтрованный список - со всеми продуктами, только без скидки или только со скидками.

Типичной ошибкой будет держать в сторе 3 массива, каждый из которых будет содержать *ID* продуктов, соответствующих каждому фильтру Так как третий массив может быть получен из текущего фильтра и объекта продуктов, лучше генерировать их используя *селектором*, как до этого:

```
{
  "productsById": {
    "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
      "title": "Blue Shirt",
      "price": 9.99,
      "discount": 1.99
    },
    "aec17a8e-4793-4687-9be4-02a6cf305590": {
      "title": "Red Hat",
      "price": 7.99,
      "discount": 0
    }
  }
}

// selector
function filteredProductIds(state, filter) {
  return _.keys(_.pickBy(state.productsById, (product) => {
    if (filter == "ALL_PRODUCTS") return true;
    if (filter == "NO_DISCOUNTS" && product.discount == 0) return true;
    if (filter == "ONLY_DISCOUNTS" && product.discount > 0) return true;
    return false;
  }));  
}
```

Селекторы выполняются при каждом изменении состояния перед перерисовкой представления. Если в селекторе много вычилений и вас беспокоит производительность, можно применить [мемоизацию](https://en.wikipedia.org/wiki/Memoization) для кэширования результатов. Взгляните на библиотеку [Reselect](https://github.com/reactjs/reselect), которая это реализует.

## 6. Нормализуйте вложенные объекты

Получается, общий посыл для всех советов - это простота. Состояние с нами надолго и мы хотим сделать работу с ним настолько безболезненной, насколько возможно. Не сложно поддерживать простоту, когда объекты данных независимы, но что делать, если есть пересечения?

Вернемся к нашему приложению. Мы хотим добавить систему управления заказами, чтобы пользователи смогли покупать несколько продуктов в рамках одного заказа. Предположим, что API сервера возвращает JSON с таким списком заказов:

```
{
  "total": 1,
  "offset": 0,
  "orders": [
    {
      "id": "14e743f8-8fa5-4520-be62-4339551383b5",
      "customer": "John Smith",
      "products": [
        {
          "id": "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0",
          "title": "Blue Shirt",
          "price": 9.99,
          "giftWrap": true,
          "notes": "It's a gift, please remove price tag"
        }
      ],
      "totalPrice": 9.99
    }
  ]
}
```

В заказе несколько продуктов, значит есть связь между двумя, которые должны быть смоделированы. Из первого совета мы уже знаем, что не стоит использовать ответ API как есть, потому что это окажется проблематичным и приведет к дублированию данных.

Хороший вариант в этом случае нормализовать данные - сделать структуру плоской и иметь для продуктов и для заказов два отдельных объекта. Поскольку оба они основаны на уникальных идентификаторах, мы сможем использовать ID для определения взаимосвязи. В результате получается такая структура:

```
{
  "productsById": {
    "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
      "title": "Blue Shirt",
      "price": 9.99
    },
    "aec17a8e-4793-4687-9be4-02a6cf305590": {
      "title": "Red Hat",
      "price": 7.99
    }
  },
  "ordersById": {
    "14e743f8-8fa5-4520-be62-4339551383b5": {
      "customer": "John Smith",
      "products": {
        "88cd7621-d3e1-42b7-b2b8-8ca82cdac2f0": {
          "giftWrap": true,
          "notes": "It's a gift, please remove price tag"
        }
      },
      "totalPrice": 9.99
    }
  }
}
```

Если мы хотим найти все продукты, которые входят в конкретный заказ, мы идем по соответствующим ключам. Каждый ключ - это ID продукта, по нему мы получаем доступ к информации в productsById. Дополнительные сведения о заказе, например пожелания покупателя по упаковке giftWrap, можно найти в отдельном объекте.

Если процесс нормализации ответов API становится утомительным, посмотрите на специальные вспомогательные библиотеки вроде [normalizr](https://github.com/paularmstrong/normalizr), которые сделают это за вас.

## 7. Считайте состояние базой данных

Все эти советы должны казаться знакомыми. Мы поступаем так же при работе с обычными [базами данных](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B7%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85).

В традиционной базе данных мы избегаем дублирования и производных, индексируем данные в объектоподобных таблицах используя первичные идентификаторы (ID) и нормализуем связи между несколькими таблицами. Практически все, о чем мы и говорили до этого момента.

Расценивая состояние приложения как базу данных в памяти, можно интуитивно понять, как структурировать его правильнее.

## Состояние проложения не менее важно, чем сам код

Если вы запомните только одну вещь из этого поста - запомните это.

В императивном программировании мы привыкли ставить код во главу угла и экономить время на продумывании "правильных" моделей для неявных внутренних структур данных вроде состояния приложения. Состояние оказывается разбросанными по разным менеджерам и контроллерам отдельными свойства, растущими сами по себе.

В декларативной парадигме все не так. В таком окружении как, например, React, система зависит от состояния. Состояние не просто важно - оно так же важно как и код, который мы пишем. Это цель экшенов Flux и источник истины для Flux представления. Такие библиотеки как Redux вращаются вокруг этого и используют такие инструменты как иммутабельность, чтобы оно стало более предсказуемым.

На продумывание состояния приложения стоит тратить время. Мы должны понимать, насколько сложным оно ставновится и как много энергии кода уходит на его поддержание. И мы определенно должны рефакторить его так же как и код, когда нам кажется, что он начинает деградировать.









в
